4-1-1 .搭建自己的SSR、静态站点生成（SSG）及封装 Vue.js 组件库 - 搭建自己的SSR

## 什么是服务器端渲染 (SSR)？

Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。

服务器渲染的 Vue.js 应用程序也可以被认为是"同构"或"通用"，因为应用程序的大部分代码都可以在**服务器**和**客户端**上运行。

## 为什么使用服务器端渲染 (SSR)？

与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：

- 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。

  请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。

- 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要。

使用服务器端渲染 (SSR) 时还需要有一些权衡之处：

- 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。
- 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。
- 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。

在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。例如，如果你正在构建一个内部仪表盘，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染 (SSR) 将是一个小题大作之举。然而，内容到达时间 (time-to-content) 要求是绝对关键的指标，在这种情况下，服务器端渲染 (SSR) 可以帮助你实现最佳的初始加载性能。

接下来我们来自己搭建一个SSR。

### 1.渲染一个Vue实例

通过node.js渲染一个服务端的vue实例模板。

- 首先创建一个空文件夹，之后初始化项目

```
npm init
```

- 安装一个vue服务端渲染器：vue-server-renderer

```
npm i vue-server-renderer
```

- 然后创建一个server.js文件

```js
const vue = require("vue");
const renderer = require('vue-server-renderer')
.createRenderer();//得到一个渲染器
const serve = express();

const app = new vue({
    template: `
<div id='app'>
<h1>{{msg}}</h1>
</div>
`,
    data: {
        msg: "洪战辉"
    },
});
renderer.renderToString(app,
(err, html) => {
    if (err) {
        res.status(500).end("网络服务器错误。")
    }
    console.log(html)
    res.end(html)
})
```

启动服务器：node server.js，输出打印html，如下：

```
<div id="app" data-server-rendered="true"><h1>洪战辉</h1></div>
```

### 2.结合到Web服务中

把我们如上的示例的server.js渲染到浏览器上：

- 首先安装express

```
npm i express
```

- 引入express，然后添加一个路由

server.js

```js
const vue = require("vue");
let express = require('express') 
const renderer = require('vue-server-renderer')
.createRenderer();
const serve = express();

serve.get("/", (req, res) => {//向外抛出一个接口 返回vue实例渲染的html数据
  const app = new vue({
    template: `
    <div id='app'>
      <h1>{{msg}}</h1>
    </div>
    `,
    data: {
      msg: "洪战辉"
    },
  });

  renderer.renderToString(app, //返回vue实例渲染的html数据
    (err, html) => {
    if (err) {
      res.status(500).end("网络服务器错误。")
    }
    // 设置响应头 设置utf-8编码 可以显示中文字符
    //res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.end(html)
  })
});

serve.listen(3000, () => { //启动监听端口
  console.log("服务器启动")
})
```

启动服务器：node server.js

![image-20211217163917349](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217163917349.png)

打开浏览器，访问监听端口，打开却是乱码。这里需要给html数据设置utf-8编码才能正确显示中文。

解决方案1：

- 在发送结果的时候设置utf-8编码

```js
 // 设置响应头 设置utf-8编码 可以显示中文字符
 res.setHeader("Content-Type", "text/html; charset=utf-8")
```

解决方案2：

- 在发送内容的时候设置一个meta标签，设置utf-8标签

```js
res.end(`
    <!DOCTYPE html>
    <html lang="en">

    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>

    <body>
    <!--vue-ssr-outlet-->
    ${html}
    </body>

    </html>
`)
```

当然，这两种方案一起设置更加保险。

看一下渲染结果：

![image-20211217164741395](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217164741395.png)

### 3.使用HTML模板

我们可以把上述的html的模板放到一个单独的html文件中，然后加载这个html文件。

我们来创建一个index.html文件：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>doc</title>
</head>
<body>
  <!--vue-ssr-outlet-->
</body>
</html>
```

这里要注意一点，一定要在body标签中加入一个注释标签：

```html
<!--vue-ssr-outlet-->
```

这个注释标签的作用是将服务端导入的渲染数据替换。将来由具体的渲染内容会在这个注释处替换。注意左右不用有空格。

在server.js使用导入的html模板：

```js
const renderer = require('vue-server-renderer')
.createRenderer({
    template:fs.readFileSync("./index.html","utf-8") //导入html模板
});
```

需要引入fs模板，详情：

```js
const vue = require("vue");
let express = require('express')
let fs = require("fs") //需要引入fs模板
const renderer = require('vue-server-renderer')
.createRenderer({
    template:fs.readFileSync("./index.html","utf-8") //导入html模板
});
const serve = express();

serve.get("/", (req, res) => {//向外抛出一个接口 返回vue实例渲染的html数据
  const app = new vue({
    template: `
    <div id='app'>
      <h1>{{msg}}</h1>
    </div>
    `,
    data: {
      msg: "洪战辉"
    },
  });

  renderer.renderToString(app, //返回vue实例渲染的html数据
    (err, html) => {
    if (err) {
      res.status(500).end("网络服务器错误。")
    }
    // 设置响应头 设置utf-8编码 可以显示中文字符
    //res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.end(`
        <!DOCTYPE html>
        <html lang="en">

        <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>

        <body>
        <!--vue-ssr-outlet-->
        ${html}
        </body>

        </html>
    `)
  })
});

serve.listen(3000, () => { //启动监听端口
  console.log("服务器启动")
})
```

他会把renderer.renderToString渲染的结果，替换导入到：

```js
.createRenderer({
    template:fs.readFileSync("./index.html","utf-8") //导入html模板
});
```

这里的html模板中。替换到 <!--vue-ssr-outlet--> 这个注释处。

这里需要删除之前提前设置的模板：

```js
 const vue = require("vue");
let express = require('express')
let fs = require("fs") //需要引入fs模板
const renderer = require('vue-server-renderer')
.createRenderer({
    template:fs.readFileSync("./index.html","utf-8") //导入html模板
});
const serve = express();

serve.get("/", (req, res) => {//向外抛出一个接口 返回vue实例渲染的html数据
  const app = new vue({
    template: `
    <div id='app'>
      <h1>{{msg}}</h1>
    </div>
    `,
    data: {
      msg: "洪战辉"
    },
  });

  renderer.renderToString(app, //返回vue实例渲染的html数据
    (err, html) => {
    if (err) {
      res.status(500).end("网络服务器错误。")
    }
    // 设置响应头 设置utf-8编码 可以显示中文字符
    /**
    * @这里删除之前设置的模板
    **/
    //res.setHeader("Content-Type", "text/html; charset=utf-8")
      // res.end(`
    // <!DOCTYPE html>
    // <html lang="en">
    
    // <head>
    //   <meta charset="UTF-8">
    //   <meta name="viewport" content="width=device-width, initial-scale=1.0">
    // </head>
    
    // <body>
    //   <!--vue-ssr-outlet-->
    //   ${html}
    // </body>
    
    // </html>
    // `)
    res.end(html)
  })
});

serve.listen(3000, () => { //启动监听端口
  console.log("服务器启动")
})
```

重新启动服务器：

![image-20211217170726763](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217170726763.png)

可以看到渲染结果和之前一样。配置公共的html模板即可。

###  4.在模板中使用外部数据

这里说明一下，HTML模板也是可以设置外部导入的数据的。

看一下提前预备使用的html模板：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  {{{meta}}}
  <title>{{title}}</title>
</head>
<body>
  <!--vue-ssr-outlet-->
</body>
</html>
```

可以看到，{{meta}}，{{title}}，这两处地方就是可以提前使用外部导入的数据了。

server.js使用导入的数据：

```js
 renderer.renderToString(app, //返回vue实例渲染的html数据
 //下面这个对象就是给模板导入的数据，他们就会渲染在html模板上
  {
    title:"hzz",
    meta:`
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    ` 
  },
    (err, html) => {
    if (err) {
      res.status(500).end("网络服务器错误。")
    }
    // 设置响应头 设置utf-8编码 可以显示中文字符
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.end(html)
  })
});
```

详情：

```js
 const vue = require("vue");
let express = require('express')
let fs = require("fs") //需要引入fs模板
const renderer = require('vue-server-renderer')
.createRenderer({
    template:fs.readFileSync("./index.html","utf-8") //导入html模板
});
const serve = express();

serve.get("/", (req, res) => {//向外抛出一个接口 返回vue实例渲染的html数据
  const app = new vue({
    template: `
    <div id='app'>
      <h1>{{msg}}</h1>
    </div>
    `,
    data: {
      msg: "洪战辉"
    },
  });

  renderer.renderToString(app, //返回vue实例渲染的html数据
  //下面这个对象就是给模板导入的数据，他们就会渲染在html模板上
  {
    title:"hzz",
    meta:`
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    ` 
  },
    (err, html) => {
    if (err) {
      res.status(500).end("网络服务器错误。")
    }
    // 设置响应头 设置utf-8编码 可以显示中文字符
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.end(html)
  })
});

serve.listen(3000, () => { //启动监听端口
  console.log("服务器启动")
})
```

注意一点：导入的数据如果是标签元素，需要渲染在html模板里的话，html模板里需要使用{{{}}这种三个大括号才能渲染标签元素。

### 4.构建配置-基本思路

看一下客户端动态交互的结构需要服务端渲染在客户端上，如下：

```js
const vue = require("vue");
let express = require('express')
let fs = require("fs")
const renderer = require('vue-server-renderer')
.createRenderer();
const serve = express();

serve.get("/", (req, res) => {
  const app = new vue({
    template: `
    <div id='app'>
      <h1>{{msg}}</h1>
      <h2>客户端交互</h2>
      <div>
        <input v-model="msg">
      </div>
      <div>
        <button @click='onClick'>点击</button>
      </div>
    </div>
    `,
    data: {
      msg: "洪战辉"
    },
    methods: {
      onClick(){
        console.log("hi hong")
      }
    },
  });


  renderer.renderToString(app,
    (err, html) => {
    if (err) {
      res.status(500).end("网络服务器错误。")
    }
    // 设置响应头 设置utf-8编码 可以显示中文字符
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.end(html)
  })
});

serve.listen(3000, () => {
  console.log("服务器启动")
})
```

如上有一段，需要浏览器客户端动态交互的html数据渲染在浏览器上。

重新启动服务器：

![image-20211217173618683](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217173618683.png)

可以看到动态结构没有发生变化。

这里要做很多额外的配置才能实现客户端动态交互。

这里有vue的服务端渲染的源码结构图：

![image-20211217181204554](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217181204554.png)

对应服务端，entry-server通过webpack打包生成一个vue-ssr-server-bundle，用于服务端渲染。

对于客户端，entry-client通过webpack打包生成一个vue-ssr-client-bundle，用于渲染到客户端，由客户端接管服务端渲染好的页面，去激活成为一个客户端页面。

官网地址：https://ssr.vuejs.org/zh/guide/structure.html#%E4%BB%8B%E7%BB%8D%E6%9E%84%E5%BB%BA%E6%AD%A5%E9%AA%A4

### 5.构建配置-源码结构

![image-20211217183255457](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217183255457.png)

参考上述结构图和官方文档：

```
https://ssr.vuejs.org/zh/guide/structure.html#%E4%BD%BF%E7%94%A8-webpack-%E7%9A%84%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84
```

#### 使用 webpack 的源码结构

一个基本项目可能像是这样：

```
src
├── components
│   ├── Foo.vue
│   ├── Bar.vue
│   └── Baz.vue
├── App.vue
├── app.js # 通用 entry(universal entry)
├── entry-client.js # 仅运行于浏览器
└── entry-server.js # 仅运行于服务器
```

- 在当前目录下生成一个src的文件夹，在生成一个vue组件，这个组件未来将渲染在浏览器服务端上：

app.vue

```vue
<template>
  <div>
    <div id="app">
      <h1>{{ msg }}</h1>
      <h2>客户端交互</h2>
      <div>
        <input v-model="msg" />
      </div>
      <div>
        <button @click="onClick">点击</button>
      </div>
    </div>
  </div>
</template>
<script>
export default {
  name:"app",
  components: {},
  // 定义属性
  data() {
    return {
      msg:"笔记接口"
    };
  },
  methods: {
    onClick(){
      console.log("9999")
    }
  },
};
</script>

<style lang='stylus' scoped></style>
```

- 创建一个app.js文件，`app.js` 是我们应用程序的「通用 entry」。在纯客户端应用程序中，我们将在此文件中创建根 Vue 实例，并直接挂载到 DOM。但是，对于服务器端渲染(SSR)，责任转移到纯客户端 entry 文件。`app.js` 简单地使用 export 导出一个 `createApp` 函数：

```js
import Vue from 'vue'
import App from './App.vue'

// 导出一个工厂函数，用于创建新的
// 应用程序、router 和 store 实例
export function createApp () {
  const app = new Vue({
    // 根实例简单的渲染应用程序组件。
    render: h => h(App)
  })
  return { app }
}
```

- 客户端入口-`entry-client.js`

客户端 entry 只需创建应用程序，并且将其挂载到 DOM 中：

```js
import { createApp } from './app'
// 客户端特定引导逻辑……
const { app } = createApp()
// 这里假定 App.vue 模板中根元素具有 `id="app"`
app.$mount('#app')
```

- 服务端入口-`entry-server.js`

服务器 entry 使用 default export 导出函数，并在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，它不会做太多事情 - 但是稍后我们将在此执行服务器端路由匹配 (server-side route matching) 和数据预取逻辑 (data pre-fetching logic)。

```js
import { createApp } from './app'

export default context => {
  const { app } = createApp();
    //服务端路由处理 数据预取...
  return app
}
```

### 6.构建配置-安装依赖

在上一步中我们已经组织好了代码结构。

现在需要安装依赖：

- 安装生产依赖

```
npm i vue vue-server-renderer express cross-env
```

| 包                  | 说明                                |
| ------------------- | ----------------------------------- |
| vue                 | Vue.js 核心库                       |
| vue-server-renderer | Vue 服务端渲染工具                  |
| express             | 基于 Node 的 Web 服务框架           |
| cross-env           | 通过 npm scripts 设置跨平台环境变量 |

- 安装开发依赖

```
npm i -D webpack webpack-cli webpack-merge webpack-node-externals @babel/core @babel/plugin-transform-runtime @babel/preset-env babel-loader css-loader url-loader file-loader rimraf vue-loader vue-template-compiler friendly-errors-webpack-plugin
```

| 包                                                           | 说明                                                  |
| :----------------------------------------------------------- | ----------------------------------------------------- |
| webpack                                                      | webpack 核心包，注意这里安装的是webpack4，@4.43.0版本 |
| webpack-cli                                                  | webpack 的命令行工具                                  |
| webpack-merge                                                | webpack 配置信息合并工具                              |
| webpack-node-externals                                       | 排除 webpack 中的 Node 模块                           |
| rimraf                                                       | 基于 Node 封装的一个跨平台 rm -rf 工具                |
| friendly-errors-webpack-plugin                               | 友好的 webpack 错误提示                               |
| @babel/core <br />@babel/plugin-transform-runtime<br />@babel/preset-env <br />babel-loader | Babel 相关工具                                        |
| vue-loader <br />vue-template-compiler                       | 处理 .vue 资源                                        |
| file-loader                                                  | 处理字体资源                                          |
| css-loade                                                    | 处理 CSS 资源                                         |
| url-loader                                                   | 处理图片资源                                          |

### 7.构建配置-webpack配置文件

上一步安装好依赖后，现在我们需要来配置webpack，来打包我们的服务端渲染SSR目录：

- 初始化 webpack 打包配置文件

目录结构如下：

```
build
├── webpack.base.config.js # 公共配置
├── webpack.client.config.js # 客户端打包配置文件
└── webpack.server.config.js # 服务端打包配置文件
```

公共配置，webpack.base.config.js：

```js
/**
 * 公共配置
 */
const VueLoaderPlugin = require('vue-loader/lib/plugin')
const path = require('path')
const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin')
const resolve = file => path.resolve(__dirname, file)

const isProd = process.env.NODE_ENV === 'production'

module.exports = {
  // 打包模式
  mode: isProd ? 'production' : 'development',
  // 打包结果
  output: {
    // 打包输出路径
    path: resolve('../dist/'),
    // 设定打包文件结果文件的前缀
    publicPath: '/dist/',
    // 打包文件名和哈希值组合 文件名使用哈希的目的是 一旦重新打包 浏览器就会重新请求
    filename: '[name].[chunkhash].js'
    
  },
  resolve: {
    alias: {
      // 路径别名，@ 指向 src
      '@': resolve('../src/')
    },
    // 可以省略的扩展名
    // 当省略扩展名的时候，按照从前往后的顺序依次解析
    extensions: ['.js', '.vue', '.json']
  },
  devtool: isProd ? 'source-map' : 'cheap-module-eval-source-map',
  module: {
    rules: [
      // 处理图片资源
      {
        test: /\.(png|jpg|gif)$/i,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 8192,
            },
          },
        ],
      },

      // 处理字体资源
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/,
        use: [
          'file-loader',
        ],
      },

      // 处理 .vue 资源
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },

      // 处理 CSS 资源
      // 它会应用到普通的 `.css` 文件
      // 以及 `.vue` 文件中的 `<style>` 块
      {
        test: /\.css$/,
        use: [
          'vue-style-loader',
          'css-loader'
        ]
      },
      
      // CSS 预处理器，参考：https://vue-loader.vuejs.org/zh/guide/pre-processors.html
      // 例如处理 Less 资源
      // {
      //   test: /\.less$/,
      //   use: [
      //     'vue-style-loader',
      //     'css-loader',
      //     'less-loader'
      //   ]
      // },
    ]
  },
  plugins: [
    new VueLoaderPlugin(),
    new FriendlyErrorsWebpackPlugin()
  ]
}
```

客户端打包配置，webpack.client.config.js：

```js
/**
 * 客户端打包配置
 */
const { merge } = require('webpack-merge')
const baseConfig = require('./webpack.base.config.js')
const VueSSRClientPlugin = require('vue-server-renderer/client-plugin')

module.exports = merge(baseConfig, {
  entry: {
    // 这里的相对路径 相对的是执行打包所处的目录
    app: './src/entry-client.js'
  },

  module: {
    rules: [
      // ES6 转 ES5 服务端不需要es6转es5 node默认支持es6
      {
        test: /\.m?js$/,
        exclude: /(node_modules|bower_components)/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'],
            cacheDirectory: true,
            plugins: ['@babel/plugin-transform-runtime']
          }
        }
      },
    ]
  },

  // 重要信息：这将 webpack 运行时分离到一个引导 chunk 中，
  // 以便可以在之后正确注入异步 chunk。
  optimization: {
    splitChunks: {
      name: "manifest",
      minChunks: Infinity
    }
  },

  plugins: [
    // 此插件在输出目录中生成 `vue-ssr-client-manifest.json`。
    new VueSSRClientPlugin()
  ]
})
```

服务端打包配置，webpack.server.config.js：

```js
/**
 * 服务端打包配置
 */
const { merge } = require('webpack-merge')
const nodeExternals = require('webpack-node-externals')
const baseConfig = require('./webpack.base.config.js')
const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')

module.exports = merge(baseConfig, {
  // 将 entry 指向应用程序的 server entry 文件
  entry: './src/entry-server.js',

  // 这允许 webpack 以 Node 适用方式处理模块加载
  // 并且还会在编译 Vue 组件时，
  // 告知 `vue-loader` 输送面向服务器代码(server-oriented code)。
  target: 'node',

  output: {
    filename: 'server-bundle.js',
    // 此处告知 server bundle 使用 Node 风格导出模块(Node-style exports)
    libraryTarget: 'commonjs2'
  },

  // 不打包 node_modules 第三方包，而是保留 require 方式直接加载
  externals: [nodeExternals({
    // 白名单中的资源依然正常打包
    allowlist: [/\.css$/]
  })],

  plugins: [
    // 这是将服务器的整个输出构建为单个 JSON 文件的插件。
    // 默认文件名为 `vue-ssr-server-bundle.json`
    new VueSSRServerPlugin()
  ]
})
```

### 8.构建配置-配置构建命令

在`package.json`生成打包命令：

```json 
"scripts": {
    "build:client": "cross-env NODE_ENV=production webpack --config build/webpack.client.config.js",
    "build:server": "cross-env NODE_ENV=production webpack --config build/webpack.server.config.js",
    "build": "rimraf dist && npm run build:client && npm run build:server",
    "start": "cross-env NODE_ENV=production node server.js",
    "dev": "node server.js"
  },
```

- `build:client`是打包客户端文件，`cross-env NODE_ENV=production` 命令表示设置环境变量为生产环境；`webpack --config build/webpack.client.config.js`这个是执行webpack打包命令并且指定webpack配置文件。
- ` "build:server"`和上述的`build:client`命令一样
- `"build"`是合并打包命令合并客户端和服务端命令，`rimraf dist`这个命令是表示在打包输出到文件夹的时候先删除dist文件夹，这个命令是我们之前安装的一个叫`rimraf`的工具

然后我们来执行打包命令：

```
npm run build
```

可以来看输出的dist文件夹：

![image-20211217225444824](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217225444824.png)

可以看到已经打包成功。

接下来我们来启动这个打包后的项目。

### 9.构建配置-启动应用

现在我们来启动打包后的应用。

如下：

server.js

```js
const vue = require("vue");
let express = require('express')
let fs = require("fs");
let template = fs.readFileSync("./vue.html","utf-8");
let serverBundle = require('./dist/vue-ssr-server-bundle.json')
let clientManifest = require("./dist/vue-ssr-client-manifest.json")
const renderer = require('vue-server-renderer')

.createBundleRenderer(serverBundle, {
  template,
  clientManifest
})
const serve = express();
serve.get("/", (req, res) => {
  renderer.renderToString({
    title:"hzh",
    meta:`
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    `
  },(err, html) => {
    if (err) {
      return res.status(500).end("网络服务器错误。")
    }
    // 设置响应头 设置utf-8编码 可以显示中文字符
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.end(html)
  })
});

serve.listen(3000, () => {
  console.log("服务器启动")
})
```

具体改造的是：

```js
let template = fs.readFileSync("./vue.html","utf-8"); //引入的模板html文件
let serverBundle = require('./dist/vue-ssr-server-bundle.json') //引入的打包后的服务端json文件
let clientManifest = require("./dist/vue-ssr-client-manifest.json")//引入的打包后的客户端json文件
const renderer = require('vue-server-renderer')
.createBundleRenderer(serverBundle, { //把之前的createRenderer函数 换成createBundleRenderer函数 serverBundle是上面引入的打包后的服务端json文件
  template, //上面的模板变量
  clientManifest//上面的客户端变量
})
```

```js
//把之前生成的vue实例删除即可  
 // const app = new vue({
  //   template: `
  //   <div id='app'>
  //     <h1>{{msg}}</h1>
  //     <h2>客户端交互</h2>
  //     <div>
  //       <input v-model="msg">
  //     </div>
  //     <div>
  //       <button @click='onClick'>点击</button>
  //     </div>
  //   </div>
  //   `,
  //   data: {
  //     msg: "洪战辉"
  //   },
  //   methods: {
  //     onClick(){
  //       console.log("hi hong")
  //     }
  //   },
  // });
```

```js
 renderer.renderToString(
 // renderer.renderToString(app, //把这里的app 变量删除 这里已经把我们的vue数据自动渲染到这里来了
    (err, html) => { //这里的html变量可以获取到渲染好的模板
    if (err) {
      res.status(500).end("网络服务器错误。")
    }
    // 设置响应头 设置utf-8编码 可以显示中文字符
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.end(html)
  })
```

然后启动项目：

```
node server.js
```

打开浏览器：

![image-20211217230921496](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217230921496.png)

看到并没有动态交互。

具体原因：

- 可以看到上图中的有一个404错误
- 在看到网络请求时，如下图

![image-20211217231241626](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217231241626.png)

可以看到请求了一个js文件，这个文件就是我们用webpack生成的文件。服务端是由这个文件的，但是客户端拿不到。

![image-20211217231341725](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217231341725.png)

所以原因是因为浏览器访问不到我们服务端启动的静态目录，服务端没有把静态目录开放出来。

解决方案：

把dist文件夹里的文件开放出来。

```js
serve.use("/dist",express.static("./dist"))//在serve这里挂载一个处理静态资源的中间件 当访问到dist文件夹后 服务端会尝试访问一个叫dist的文件夹是否在项目的根目录中 把这个文件夹开放出来
```

在server.js里

```js
const vue = require("vue");
let express = require('express')
let fs = require("fs");
let template = fs.readFileSync("./vue.html","utf-8");
let serverBundle = require('./dist/vue-ssr-server-bundle.json')
let clientManifest = require("./dist/vue-ssr-client-manifest.json")
const renderer = require('vue-server-renderer')
// .createRenderer({
//   template:fs.readFileSync("./vue.html","utf-8")
// });
.createBundleRenderer(serverBundle, {
  template,
  clientManifest
})
const serve = express();
serve.use("/dist",express.static("./dist"))//在serve这里挂载一个处理静态资源的中间件 当访问到dist文件夹后 服务端会尝试访问一个叫dist的文件夹是否在项目的根目录中
```

然后再来看一下客户端浏览器：

![image-20211217231948088](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217231948088.png)

已经可以动态改变了。

###  10.构建配置-解析渲染流程

服务端向外抛出一个路由接口，当浏览器访问这个路由，就会被服务端匹配：

```js
const vue = require("vue");
let express = require('express')
let fs = require("fs");
let template = fs.readFileSync("./vue.html","utf-8");
let serverBundle = require('./dist/vue-ssr-server-bundle.json')
let clientManifest = require("./dist/vue-ssr-client-manifest.json")
const renderer = require('vue-server-renderer')
.createBundleRenderer(serverBundle, {
  template,
  clientManifest
})
const serve = express();
serve.use("/dist",express.static("./dist"))
serve.get("/", (req, res) => { //向外抛出的路由 匹配浏览器客户端
  renderer.renderToString((err, html) => {
    if (err) {
      return res.status(500).end("网络服务器错误。")
    }
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.end(html)
  })
});

serve.listen(3000, () => {
  console.log("服务器启动")
})
```

- 当被匹配到后，执行`renderer.renderToString`函数渲染好vue实例向客户端返回，但是我们没有看到vue实例在哪里生成的。

- 来看一下renderer函数：

```js
const renderer = require('vue-server-renderer')
.createBundleRenderer(serverBundle, { //vue实例就是在serverBundle里生成的
  template,
  clientManifest
})
```

#### 服务端渲染流程

`renderer`函数就是由`require('vue-server-renderer')`这个插件返回的`createBundleRenderer`函数生成的，这个方法第一个参数就是`serverBundle`

`let serverBundle = require('./dist/vue-ssr-server-bundle.json')`这个参数是我们webpack打包后生成的json文件。

`vue-ssr-server-bundle.json`打开这个文件：

```json
{
  "entry": "server-bundle.js",
  "files": {
    "server-bundle.js": ...
  },
  "maps": {
    ...
  }
}
```

`server-bundle.js`这个值就是我们src里的js文件用于执行服务端入口的文件。他把整个文件以json格式的方式放在了这个json文件里了。

![image-20211217234224111](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211217234224111.png)

`maps`这个值就是代码地图，用于我们开发调试用的。可以映射开发打包前的代码到浏览器，方便错误代码调试。

`entry`就是入口文件加载。

当`renderer`函数在渲染的时候会来加载`let serverBundle = require('./dist/vue-ssr-server-bundle.json')`这个参数，当加载这个参数后他就是执行文件加载入口`"server-bundle.js",`就会加载我们src里的js文件用于执行服务端入口的文件就是`entry-serve.js`

`entry-serve.js`如下：

```js
import { createApp } from './app'
// 服务端启动入口
export default context => {
  const { app } = createApp()
  // 服务端路由处理 数据预取
  return app
}
```

可以看到`entry-serve.js`引入了app.vue文件并且返回这个app.vue文件，所以当`renderer`函数在渲染的时候会加载这个app.vue文件，并且把渲染的结构注入到了template模板中了。

#### 客户端渲染流程

`renderer`函数就是由`require('vue-server-renderer')`这个插件返回的`createBundleRenderer`函数生成的，这个方法第一个参数就是`serverBundle`，而他第二个参数就是就是一个对象，里面加载了`clientManifest`

`clientManifest`这个值是`let clientManifest = require("./dist/vue-ssr-client-manifest.json")`这里引入的，其实就是我们webpack打包后的`vue-ssr-client-manifest.json`文件。
我们看一下`vue-ssr-client-manifest.json`这个文件：

```json
{
  "publicPath": "/dist/",
  "all": [
    "app.09a53c4682ed384c930e.js"
  ],
  "initial": [
    "app.09a53c4682ed384c930e.js"
  ],
  "async": [],
  "modules": {
    "65ed9a2e": [
      0
    ],
    "6fbc4fdc": [
      0
    ]
  }
}
```

`vue-ssr-client-manifest.json`这个文件是我们客户端打包资源的一个构建清单。这个清单就是描述了我们客户端构建来的这些资源信息。

`"publicPath"`,这个值是代表我们打包出口静态资源目录。

`"all"`代表客户端所有构建出来的资源名称。

`"initial"`代表在serverRender渲染的时候，把这个值里的资源自动注入到我们的html模板当中。

`"modules"`代表我们原生信息模块也就是我们在src里写的js模块对他们的一些信息说明，首先通过特定的哈希值代码该模块，后面的0和1就是`"all"`里的数组索引值。

#### 以下是客户端激活的官方文档：

所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。

在 `entry-client.js` 中，我们用下面这行挂载(mount)应用程序：

```js
// 这里假定 App.vue template 根元素的 `id="app"`
app.$mount('#app')
```

由于服务器已经渲染好了 HTML，我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要"激活"这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。

如果你检查服务器渲染的输出结果，你会注意到应用程序的根元素上添加了一个特殊的属性：

```html
<div id="app" data-server-rendered="true">
```

`data-server-rendered` 特殊属性，让客户端 Vue 知道这部分 HTML 是由 Vue 在服务端渲染的，并且应该以激活模式进行挂载。注意，这里并没有添加 `id="app"`，而是添加 `data-server-rendered` 属性：你需要自行添加 ID 或其他能够选取到应用程序根元素的选择器，否则应用程序将无法正常激活。

注意，在没有 `data-server-rendered` 属性的元素上，还可以向 `$mount` 函数的 `hydrating` 参数位置传入 `true`，来强制使用激活模式(hydration)：

```js
// 强制使用应用程序的激活模式
app.$mount('#app', true)
```

在开发模式下，Vue 将推断客户端生成的虚拟 DOM 树 (virtual DOM tree)，是否与从服务器渲染的 DOM 结构 (DOM structure) 匹配。如果无法匹配，它将退出混合模式，丢弃现有的 DOM 并从头开始渲染。**在生产模式下，此检测会被跳过，以避免性能损耗。**

#### [#](https://ssr.vuejs.org/zh/guide/hydration.html#一些需要注意的坑)一些需要注意的坑

使用「SSR + 客户端混合」时，需要了解的一件事是，浏览器可能会更改的一些特殊的 HTML 结构。例如，当你在 Vue 模板中写入：

```html
<table>
  <tr><td>hi</td></tr>
</table>
```

浏览器会在 `<table>` 内部自动注入 `<tbody>`，然而，由于 Vue 生成的虚拟 DOM (virtual DOM) 不包含 `<tbody>`，所以会导致无法匹配。为能够正确匹配，请确保在模板中写入有效的 HTML。

### 11.构建配置开发模式-基本思路

现在的模式是每当我们重新修改源代码之后，都要重新构建一次，非常麻烦。

现在我们想做的是，开发模式构建，每当我们修改完源代码之后都会自动构建，并且自动重启服务端和自动刷新浏览器。

怎么做：

- 首先我们的入口点在renderer这个函数中：

server.js

```js
let template = fs.readFileSync("./vue.html","utf-8");
let serverBundle = require('./dist/vue-ssr-server-bundle.json')
let clientManifest = require("./dist/vue-ssr-client-manifest.json")
const renderer = require('vue-server-renderer') //入口点
// .createRenderer({
//   template:fs.readFileSync("./vue.html","utf-8")
// });
.createBundleRenderer(serverBundle, {
  template,
  clientManifest
})
```

因为这个函数的生成是由我们打包的结果然后返回的函数，包括`template`和`serverBundle`以及`clientManifest`这些引入的文件生成的变量。所以一旦这些打包后的资源文件发生改变，我们就重新调用`createBundleRenderer`函数生成新的`renderer`函数。

- 在`package.json`生成新的命令：

```json
  "scripts": {
      ...
    "start": "cross-env NODE_ENV=production node server.js",
    "dev": "node server.js"
  },
```

`"start"`这个命令，`cross-env NODE_ENV=production`这里代表是环境变量设置生产环境，`node server.js`启动服务器。

`"dev"`这个命令，是直接启动服务器，不设置环境变量。

- 然后在server.js里重新配置判断是不是开发环境，如果是开发环境就监听打包构建并且重新生成渲染器：

```js
// let template = fs.readFileSync("./vue.html","utf-8");
// let serverBundle = require('./dist/vue-ssr-server-bundle.json')
// let clientManifest = require("./dist/vue-ssr-client-manifest.json")
// const renderer = require('vue-server-renderer')
// // .createRenderer({
// //   template:fs.readFileSync("./vue.html","utf-8")
// // });
// .createBundleRenderer(serverBundle, {
//   template,
//   clientManifest
// })
//把上面的代码删除
let renderer
// 获取环境变量
let isProd = process.env.NODE_ENV === "production";
if (isProd) {
  //如果是生产环境
  let template = fs.readFileSync("./vue.html", "utf-8");
  let serverBundle = require('./dist/vue-ssr-server-bundle.json')
  let clientManifest = require("./dist/vue-ssr-client-manifest.json")
  renderer = require('vue-server-renderer')
    // .createRenderer({
    //   template:fs.readFileSync("./vue.html","utf-8")
    // });
    .createBundleRenderer(serverBundle, {
      template,
      clientManifest
    })
}else{
  //如果是开发环境
  // 开发模式==》监视打包构建==》重新生成renderer渲染器
  
}
```

第一点需要完善的：如果是开发环境这里的代码我们下面来完善。

```js
// serve.get("/", (req, res) => {
//   // const app = new vue({
//   //   template: `
//   //   <div id='app'>
//   //     <h1>{{msg}}</h1>
//   //   </div>
//   //   `,
//   //   data: {
//   //     msg: "hzh"
//   //   }
//   // });


//   renderer.renderToString({
//     title: "hzh",
//     meta: `
//       <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     `
//   }, (err, html) => {
//     if (err) {
//       return res.status(500).end("网络服务器错误。")
//     }
//     // 设置响应头 设置utf-8编码 可以显示中文字符
//     res.setHeader("Content-Type", "text/html; charset=utf-8")
//     // console.log(html);
//     // 设置 <meta charset="UTF-8"> 这个标签可以设置utf-8编码
//     // res.end(`
//     // <!DOCTYPE html>
//     // <html lang="en">

//     // <head>
//     //   <meta charset="UTF-8">
//     //   <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     // </head>

//     // <body>
//     //   <!--vue-ssr-outlet-->
//     //   ${html}
//     // </body>

//     // </html>
//     // `)
//     res.end(html)
//   })
// });
//删除上述代码
//把渲染器（vue的SSR渲染器） 渲染的html结构数据 返回 封装成一个函数
let render =  (req, res) => {
  renderer.renderToString({
    title: "hzh",
    meta: `
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    `
  }, (err, html) => {
    if (err) {
      return res.status(500).end("网络服务器错误。")
    }
    // 设置响应头 设置utf-8编码 可以显示中文字符
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.end(html)
  })
}

// 匹配路由 然后根据开发环境执行不同的渲染器代码
serve.get("/", 
  isProd ? render
  : (req,res=>{
    // 等待有了renderer渲染器以后 调用render进行渲染
    render()
  })
)
```

第二点需要完善的：等待有了renderer渲染器以后，这里还需要在下一步完善。

### 12.构建配置开发模式-提取处理模块

这里把上面的两点完善，提取出来并且单独写成一个模块。

- 第一点需要完善的：如果是开发环境这里的代码我们下面来完善。

我们首先写一个模块用于处理监视打包后的文件：

模块名：\build\setup-dev-server.js

```js
module.exports = (server,cb) =>{
  const onReady = new Promise(); //这里写成promise是因为要让服务端等待这里打包完成
  // 监视构建 =》 更新 renderer
  return onReady;
}
```

然后在server.js里引入这个模块

```js
let {
  createBundleRenderer
} = require('vue-server-renderer') //这里把共同的vueSSR渲染器引入
const setupDevServer = require("./build/setup-dev-server");
// 创建一个定时器 监视打包是否完成
let onReady;
let renderer;
let isProd = process.env.NODE_ENV === "production";
if (isProd) {
  let template = fs.readFileSync("./vue.html", "utf-8");
  let serverBundle = require('./dist/vue-ssr-server-bundle.json')
  let clientManifest = require("./dist/vue-ssr-client-manifest.json")
  renderer = createBundleRenderer(serverBundle, {
    template,
    clientManifest
  })
} else {
  //如果是开发环境
  // 开发模式==》监视打包构建==》重新生成renderer渲染器
  setupDevServer(serve, (serverBundle, template, clientManifest) => {
    // 监视打包完成 如果返回正确的promise则表示打包完成
    onReady = createBundleRenderer(serverBundle, {
      template,
      clientManifest
    })
  })
}
```

第二点需要完善的：等待有了renderer渲染器以后。在server.js的路由处理部分加上这个promise返回的结果：

```js
// 匹配路由 然后根据开发环境执行不同的渲染器代码
serve.get("/",
  isProd ? render :
  async (req, res => {
    //TOOD 等待有了renderer渲染器以后 调用render进行渲染
    // 监视打包完成 如果返回正确的promise则表示打包完成
    await onReady;
    render()
  })
)
```

###  13.构建配置开发模式-update更新函数

我们这里接着完善上述第一点的函数：监视构建结果，并且更新处理renderer函数。

模块名：\build\setup-dev-server.js

```js
module.exports = (server,cb) =>{
  const onReady = new Promise();
  // 监视构建 =》 更新 renderer
  return onReady;
}
```

更新：

```js
module.exports = (server,cb) =>{
  // 定义一个变量拿到promise返回的值
  let ready;
  // const onReady = new Promise(r => ready = r);
  const onReady = new Promise((res,err)=>{
    // 这个res调用则说明将promise状态改成 成功状态
    ready = res
  });
  // 监视构建 =》 更新 renderer
  let template
  let serverBundle
  let clientManifest
  //更新函数 调用回调函数更新渲染器
  let update = ()=>{
    // 这里是说明如果已经拿到构建结果后的文件 则执行回调函数
    // 回调函数也就是渲染器 重新渲染
    if(template && serverBundle && clientManifest){
      ready()
      cb(serverBundle,template,clientManifest)
    }
  };
  // 监视构建 template -> 调用 update -> 更新 Renderer 渲染器
  // 监视构建 serverBundle -> 调用 update -> 更新 Renderer 渲染器
  // 监视构建 clientManifest -> 调用 update -> 更新 Renderer 渲染器
  return onReady;
}
```

### 14.构建配置开发模式-处理模板文件

监视构建 template -> 调用 update -> 更新 Renderer 渲染器

代码：

```js
 // 监视构建 template -> 调用 update -> 更新 Renderer 渲染器
  let templatePath = path.resolve(__dirname,"../vue.html")
  template = fs.readFileSync(templatePath,"utf-8");
  console.log(template);
  // chokidar可以监控本地文件
  chokidar.watch(templatePath).on("change",()=>{
    console.log("监控");
    update();
  })
```

这里引用了一个`chokidar`模块他可以监控本地文件，原生的node.js的watch监控有缺点，这个更加完善一点。

### 15.构建配置开发模式-服务端监视打包

监视构建 serverBundle -> 调用 update -> 更新 Renderer 渲染器

代码：

```js
  // 监视构建 serverBundle -> 调用 update -> 更新 Renderer 渲染器
  // 这里需要调用webpack 里面需要传入服务端的webpack配置
  // 注意这里引入安装的是 webpack4版本 "webpack": "^4.43.0",
  let serverCompiler = webpack(require("./webpack.server.config"));
  //  监控本地服务端构建后的文件
  serverCompiler.watch({}, (err, stats) => {
    if (err) throw err;
    if (stats.hasErrors()) return;
    console.log("服务端监控")
    serverBundle = JSON.parse(
      serverDevMiddleware.fileSystem.readFileSync(resolve('../dist/vue-ssr-server-bundle.json'), 'utf-8')
    )
    console.log(serverBundle)
    update()
  })

```

### 16. 构建配置开发模式-把数据写入内存中

webpack在打包构建的时候，会把构建的结果存储在本地磁盘中进行读写操作，这个在生产模式下会怎么操作没有问题，但是在开发模式下这么频繁的操作有影响效率，磁盘操作速度不够快，如果把构建过程中的文件放在内存中操作这样速度快很多。

解决方案：

安装官方提供的插件`webpack-dev-middleware`

```
npm i webpack-dev-middleware
```

使用：

setup-dev-server.js

```js
//引入
const devMiddleware = require('webpack-dev-middleware')
....
let serverCompiler = webpack(require("./webpack.server.config"));
//使用webpack-dev-middleware
const serverDevMiddleware = devMiddleware(serverCompiler, {
    logLevel: 'silent' // 关闭日志输出，由 FriendlyErrorsWebpackPlugin 处理
})
serverCompiler.watch({}, (err, stats) => {
    if (err) throw err;
    if (stats.hasErrors()) return;
    console.log("服务端监控")
    serverBundle = JSON.parse(
        serverDevMiddleware.fileSystem.readFileSync(resolve('../dist/vue-ssr-server-bundle.json'), 'utf-8')
    )
    console.log(serverBundle)
    update()
})
```

我们来把本地磁盘的dist文件删除。然后执行启动服务端：

![image-20211219052757417](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211219052757417.png)

可以看到本地已经删除dist文件夹了，但是也提示构建成功，说明已经在内存在打包完成了。

注意我们可以把*监控本地服务端构建后的文件*的watch删除，因为他`webpack-dev-middleware`他默认就可以监控文件。

![image-20211219053209331](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211219053209331.png)

可以看到也可以构建成功。构建成功后也不会关闭，说明正在监控构建文件。

这里如果把监控本地服务端构建后的文件的watch删除后，怎么更新编译器呢？

解决方案：

```js
const serverDevMiddleware = devMiddleware(serverCompiler, {
  logLevel: 'silent' // 关闭日志输出，由 FriendlyErrorsWebpackPlugin 处理
})
//这里给webpack的设置一个钩子函数，
//done这个钩子函数意思就是等他构建完成后在执行里面的回调函数
//tap这个钩子函数的第一个参数就是一个标识
serverCompiler.hooks.done.tap('server', () => {
  serverBundle = JSON.parse(
    //serverDevMiddleware.fileSystem这个东西拿到就是类似于node 的 fs模块拿到的构建文件，但是这个是内存中的数据
    serverDevMiddleware.fileSystem.readFileSync(resolve('../dist/vue-ssr-server-bundle.json'), 'utf-8')
  )
  update()
})
```

###  17.构建配置开发模式-客户端构建

*监视构建 clientManifest -> 调用 update -> 更新 Renderer 渲染器*,这里的操作思路和服务端构建差不多。

```js
// 监视构建 clientManifest -> 调用 update -> 更新 Renderer 渲染器
let clientCompiler = webpack(require("./webpack.client.config"));
const clientDevMiddleware = devMiddleware(clientCompiler, {
  logLevel: 'silent', // 关闭日志输出，由 FriendlyErrorsWebpackPlugin 处理
  publicPath: require("./webpack.client.config").output.publicPath
})
//这里给webpack的设置一个钩子函数，
//done这个钩子函数意思就是等他构建完成后在执行里面的回调函数
//tap这个钩子函数的第一个参数就是一个标识
clientCompiler.hooks.done.tap('server', () => {
  clientManifest = JSON.parse(
    //serverDevMiddleware.fileSystem这个东西拿到就是类似于node 的 fs模块拿到的构建文件，但是这个是内存中的数据
    clientDevMiddleware.fileSystem.readFileSync(resolve('../dist/vue-ssr-client-manifest.json'), 'utf-8')
  )
  update()
})
```

现在可以启动项目了：

```
npm run dev
```

但是浏览器却打不开，这是因为如下：

server.js

```js
serve.get("/",
  isProd ? render :
  async (req, res) => {
    console.log("2")
    await onReady;
    render(req, res)//这里要传参数req和res
  })

```

打开浏览器：

![image-20211219080221555](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211219080221555.png)

浏览器不能交互，而且出现了404错误，因为我们在服务端监听时和客户端监听时用的`webpack-dev-middleware`在内存中读写缓存文件的，在如下：

server.js

```js
//当访问到dist文件夹后 服务端会尝试访问一个叫dist的文件夹是否在项目的根目录中
serve.use("/dist", express.static("./dist"))
```

这里读取的是本地磁盘中的文件，但是内存中的构建后的缓存文件却读不到。

解决方案：

我们在调用`setup-dev-server.js`模块的时候，调用这个函数时传入了一个serve参数：

```js
//这里传入了serve 也就是node的express服务端框架
onReady = setupDevServer(serve, (serverBundle, template, clientManifest) => {
  renderer = createBundleRenderer(serverBundle, {
    template,
    clientManifest
  })
})
```

我们只要在`setup-dev-server.js`里调用serve.use给内存里的数据挂载到静态服务器中，而且这里只用挂载客户端的构建后的内存数据。

如下：

```js
// 重要！！！将 clientDevMiddleware 挂载到 Express 服务中，提供对其内部内存中数据的访问
server.use(clientDevMiddleware)
```

![image-20211219081331877](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211219081331877.png)

这里可以看到浏览器渲染正确了。

### 18. 构建配置开发模式-热更新

接下来我们来实现热更新，热更新就是，源代码改变之后客户端自动更新刷新，不用手动刷新。

- 安装webpack官方插件：

```
npm i hotMiddleware
```

- 在项目中引入并且使用：

`setup-dev-server.js`

```js
//引入热更新hotMiddleware
const hotMiddleware = require('webpack-hot-middleware')
```

然后在插件中加入：

`setup-dev-server.js`

```js
const clientConfig = require('./webpack.client.config')
clientConfig.plugins.push(new webpack.HotModuleReplacementPlugin())
clientConfig.entry.app = [
    'webpack-hot-middleware/client?quiet=true&reload=true', // 和服务端交互处理热更新一个客户端脚本
    clientConfig.entry.app
]
clientConfig.output.filename = '[name].js' // 热更新模式下确保一致的 hash

....
server.use(hotMiddleware(clientCompiler, {
    log: false // 关闭它本身的日志输出
}))
```

### 19. 编写通用应用注意事项

现在我们已经把vue SSR的基础结构编写完成了，虽然有很多不足之处但是也够我们基础的使用了。

官方文档：https://ssr.vuejs.org/zh/guide/universal.html

- 状态污染的问题

什么是状态污染：

在纯客户端应用程序 (client-only app) 中，每个用户会在他们各自的浏览器中使用新的应用程序实例。对于服务器端渲染，我们也希望如此：**每个请求应该都是全新的、独立的应用程序实例，以便不会有交叉请求造成的状态污染** (cross-request state pollution)。

例如：

```js
const app = new Vue({
  // 根实例简单的渲染应用程序组件。
   render: h => h(App)
})

return { app }
```

如果是上述这样的话，他是返回一个实例，但是这样的实例却是多个用户浏览器公用一个状态应用类型数据。

如下：

```js
export function createApp () {
  const app = new Vue({
    // 根实例简单的渲染应用程序组件。
    render: h => h(App)
  })
  return { app }
}
```

应该是上述这样的用函数包裹返回一个实例对象，这样创建的实例都是全新的实例对象，不会造成状态污染。

- 在服务器上进行数据预取

因为实际的渲染过程需要确定性，所以我们也将在服务器上“预取”数据 ("pre-fetching" data) - 这意味着在我们开始渲染时，我们的应用程序就已经解析完成其状态。也就是说，将数据进行响应式的过程在服务器上是多余的，所以默认情况下禁用。禁用响应式数据，还可以避免将「数据」转换为「响应式对象」的性能开销。

也就是说在服务端数据是没有响应式变化的，**禁用响应式数据，还可以避免将「数据」转换为「响应式对象」的性能开销。**

- 组件生命周期钩子函数


由于没有动态更新，所有的生命周期钩子函数中，**只有 `beforeCreate` 和 `created` 会在服务器端渲染 (SSR) 过程中被调用**。这就是说任何其他生命周期钩子函数中的代码（例如 `beforeMount` 或 `mounted`），只会在客户端执行。

此外还需要注意的是，你应该避免在 `beforeCreate` 和 `created` 生命周期时产生全局副作用的代码，例如在其中使用 `setInterval` 设置 timer。在纯客户端 (client-side only) 的代码中，我们可以设置一个 timer，然后在 `beforeDestroy` 或 `destroyed` 生命周期时将其销毁。但是，由于在 SSR 期间并不会调用销毁钩子函数，所以 timer 将永远保留下来。为了避免这种情况，**请将副作用代码移动到 `beforeMount` 或 `mounted` 生命周期中。**

总结：也就是说因为我们在服务端没有响应式数据的变化，所以我们的生命周期钩子函数只有只有 `beforeCreate` 和 `created` 会在服务器端渲染 (SSR) 过程中被调用。这点需要注意。

- 访问特定平台(Platform-Specific) API

通用代码不可接受特定平台的 API，因此如果你的代码中，直接使用了像 `window` 或 `document`，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此。

对于共享于服务器和客户端，但用于不同平台 API 的任务(task)，建议将平台特定实现包含在通用 API 中，或者使用为你执行此操作的 library。**例如，[axios](https://github.com/axios/axios) 是一个 HTTP 客户端，可以向服务器和客户端都暴露相同的 API。**

对于仅浏览器可用的 API，通常方式是，在「纯客户端 (client-only)」的生命周期钩子函数中惰性访问 (lazily access) 它们。

请注意，考虑到如果第三方 library 不是以上面的通用用法编写，则将其集成到服务器渲染的应用程序中，可能会很棘手。你*可能*要通过模拟 (mock) 一些全局变量来使其正常运行，但这只是 hack 的做法，并且可能会干扰到其他 library 的环境检测代码。

**例如：在服务端，我们要访问浏览器端的变量，像 `window` 或 `document`，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此**。

- 自定义指令

大多数自定义指令直接操作 DOM，因此会在服务器端渲染 (SSR) 过程中导致错误。有两种方法可以解决这个问题：

1. 推荐使用组件作为抽象机制，并运行在「虚拟 DOM 层级(Virtual-DOM level)」（例如，使用渲染函数(render function)）。
2. 如果你有一个自定义指令，但是不是很容易替换为组件，则可以在创建服务器 renderer 时，使用 [`directives`](https://ssr.vuejs.org/zh/api/#directives) 选项所提供"服务器端版本(server-side version)"。

### 20.路由处理-配置VueRouter

我们现在来配置SSR项目的路由。

参考官方文档：https://ssr.vuejs.org/zh/guide/routing.html#%E4%BD%BF%E7%94%A8-vue-router-%E7%9A%84%E8%B7%AF%E7%94%B1

具体代码如下：

首先，我们需要先下载安装vue-router

```
npm i vue-router
```

然后在项目中创建一个router的文件夹和配置一个路由组件的文件夹：

```
src
├── router
│   ├── index.js
├── pages
│   ├── Home.vue
│   ├── About.vue
```

代码如下：

`About.vue`

```vue
<template>
  <div>
    <h1>about页面</h1>
  </div>
</template>

<script>
export default {
  name:"about",
}
</script>
```

`Home.vue`

```vue
<template>
  <div>
    <h1>home页面</h1>
  </div>
</template>

<script>
export default {
  name:"about",
}
</script>
```

`index.js`

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import Home from '@/pages/Home'
Vue.use(VueRouter)
export const createRouter = () => {
  const router = new VueRouter({
    mode: 'history', //同构应用不能使用hash模式 hisstory兼容前后端
    routes: [
      {
        path: '/',
        name: 'home',
        component: Home
      },
      {
        path: '/about',
        name: 'about',
          //这里我们使用了路由懒加载，在该页面被显示时才被会加载
        component: () => import('@/pages/About')
      },
        //剩余路由接收
      {
        path: '*',
        name: 'error404',
        component: () => import('@/pages/About')
      }
    ]
  })
  return router
}
```

### 21.路由处理-将路由注册到根实例

我们还需要在`app.js`里也就是根实例中配置一下。

代码如下：

`app.js`

```js
import Vue from 'vue'
import App from './app.vue'
import { createRouter } from './router'

// 导出一个工厂函数，用于创建新的
// 应用程序、router 和 store 实例
export function createApp () {
  let router = createRouter()
  const app = new Vue({
    router, // 把路由挂载到 Vue 根实例中
    // 根实例简单的渲染应用程序组件。
    render: h => h(App)
  })
  return { app,router }
}
```

需要注意的是，我们在挂载路由实例和返回`app`实例的同时也需要返回路由对象`router`。

### 22. 路由处理-适配服务端入口

官方文档说明：服务器 entry 使用 default export 导出函数，并在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，它不会做太多事情 - 但是稍后我们将在此执行服务器端路由匹配 (server-side route matching) 和数据预取逻辑 (data pre-fetching logic)。

所以在上述官方文档说明中，我们也需要在`entry-server.js`这个文件，也就是适配服务端入口的文件进行路由处理配置。

代码如下：

```js
// entry-server.js
import { createApp } from './app'
export default context => {
  // 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise，
    // 以便服务器能够等待所有的内容在渲染前，
    // 就已经准备就绪。
  return new Promise((resolve, reject) => {
    const { app, router } = createApp()

    // 设置服务器端 router 的位置 context上下文对象也就是我们在server.js里的传入的配置文件{title:"hzh",meta:.....}在这里我们需要多传入一个url 这里在服务端他会帮我们跳转到传入的url中
    router.push(context.url)

    // 等到 router 将可能的异步组件和钩子函数解析完
    router.onReady(() => {
      const matchedComponents = router.getMatchedComponents()
      // 匹配不到的路由，执行 reject 函数，并返回 404
      if (!matchedComponents.length) {
        return reject({ code: 404 })
      }

      // Promise 应该 resolve 应用程序实例，以便它可以渲染
      resolve(app)
    }, reject)
  })
}
```

上述也解释了为什么要返回promise对象，因为我们路由懒加载需要动态加载模块也就是异步加载或者异步路由钩子函数。

 `router.push(context.url)`设置服务器端 router 的位置 context上下文对象也就是我们在server.js里的传入的配置文件`{title:"hzh",meta:.....}`这里我们需要多传入一个url 这里在服务端他会帮我们跳转到传入的url中。

这里是用promise的then函数加载的，所以我们可以同async和await改造代码结构变得更加清晰。

`entry-server.js`的async和await改造

```js
// // entry-server.js
import {
  createApp
} from './app'

export default async context => {
  // 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise，
  // 以便服务器能够等待所有的内容在渲染前，
  // 就已经准备就绪。
  const {
    app,
    router
  } = createApp()

  // 设置服务器端 router 的位置
  router.push(context.url)

  // 等到 router 将可能的异步组件和钩子函数解析完 把this转换到router里的this
  await new Promise(router.onReady.bind(router))
  return app;
}
```

### 23.路由处理-服务端server适配

在`server.js`里应用路由改造的不多。

如下：

`server.js`

```js
let render = (req, res) => {
  console.log("963")
  renderer.renderToString({
    title: "hzh",
    meta: `
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    `,
    url: req.url //添加一个请求路由url
  }, (err, html) => {
    if (err) {
      return res.status(500).end("网络服务器错误。")
    }
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    console.log(html)
    res.end(html)
  })
}
```

改造点只有一个也就是在上述我们提过在传入上下文对象的同时传入一个url。

因为`renderer.renderToString`的返回是以回调函数的方式支持promise,在这里我们还可以把他改成async和await的方式：

`server.js`async和await的方式

```js
let render = async (req, res) => {
  try {
    let html = await renderer.renderToString({
      title: "hzh",
      meta: `
      <meta name="description" content="hzh">
      `,
      url: req.url
    });
    // 设置响应头 设置utf-8编码 可以显示中文字符
    res.setHeader("Content-Type", "text/html; charset=utf-8")
    res.end(html)
  } catch (err) {
    return res.status(500).end("网络服务器错误。")
  }
}
```

还需要在`server.js`里的路由入口改造一下，因为vue路由的请求如果请求到不存在的路由时会返回404，但是我们需要在vue路由的处理当中处理错误的路由显示不同的组件页面，如果请求`/a`返回的就是404因为我们在服务端改变没有处理`/a`,所以我们需要处理一下服务端请求过来的路由。

```js
serve.get("*",//放所有的路由进来 vue-router处理不存在的路由组件
  isProd ? render :
  async (req, res) => {
    console.log("2")
    //TOOD 等待有了renderer渲染器以后 调用render进行渲染
    // 监视打包完成 如果返回正确的promise则表示打包完成
    await onReady;
    render(req, res)
  })
```

### 24.路由处理-适配客户端入口

在我们的客户端入口处理vue-router最后的的配置：

需要注意的是，你仍然需要在挂载 app 之前调用 `router.onReady`，因为路由器必须要提前解析路由配置中的异步组件，才能正确地调用组件中可能存在的路由钩子。这一步我们已经在我们的服务器入口 (server entry) 中实现过了，现在我们只需要更新客户端入口 (client entry)：

```js
/**
 * 客户端入口
 */
import { createApp } from './app'

// 客户端特定引导逻辑……

const { app , router} = createApp()

// 这里假定 App.vue 模板中根元素具有 `id="app"`
router.onReady(() => {
  app.$mount('#app')
})
```

因为我们需要要路由懒加载和异步钩子函数的处理，这里需要等待router的处理完成后才可以挂载页面。

### 25. 路由处理-处理完成

路由处理配置我们已经完成。

现在我们来写一些路由相关的代码：

现在在pages文件夹里又添加了一个404错误路由组件。

`app.vue`

```vue
<template>
  <div>
    <div id="app">
      <h1>{{ msg }}</h1>
      <h2>客户端交互</h2>
      <div>
        <input v-model="msg" />
      </div>
      <div>
        <button @click="onClick">点击23</button>
      </div>
      <h1>路由</h1>
      <br />
      <ul>
        <li>
          <router-link to="/">home</router-link>
        </li>
        <li>
          <router-link to="/about">about</router-link>
        </li>
      </ul>
      <!-- 路由出口 -->
      <router-view />
    </div>
  </div>
</template>

<script>
export default {
  name: "app",
};
</script>

```

开始启动项目：

```
npm run dev
```

![image-20211224043845449](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211224043845449.png)

我们这里分析一下，浏览器在服务端渲染完成后给客户端的渲染：

![image-20211224060955710](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211224060955710.png)

看一看到上述的网络加载的文件是这些，在我重新和页面交互后没有发出新的请求，说明此时我们的页面交互逻辑是由客户端接管的。

我们来执行一下打包命令：

```
npm run build
```

打包出一个dist文件夹：

![image-20211224061214286](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211224061214286.png)

可以看到，打包出了两个chunk.js，这两个js文件其实就是我们懒加载的异步路由组件，因为懒加载的缘故所以在页面首次渲染时不会直接加载出来，需要预加载在页面需要的时候才会加载这两个懒加载组件。在上述的网络截图中我们也看到，网络请求也加载了这俩js文件。

为什么懒加载，在网络请求的时候也加载了这俩异步组件呢？不是应该在需要的时候才会加载这些懒加载的组件呢？

首先我们来看一下图：

![image-20211224061818276](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211224061818276.png)

可以看到在网络请求的过程中，请求过来的html渲染好的页面时，有3个`link`标签，他们的`rel`属性分别是`preload` 、`prefetch`，其实这些标签就意味着这几个懒加载组件是预加载的，在网页加载接管客户端的时候只有`script`标签是在渲染页面是执行的下载这些js的代码的，`script`标签会阻塞网页的渲染，而`link`标签是提前预加载的代码js在后续如果需要使用到`link`里的代码时才会被加载出来,，他不会影响网页的渲染和阻塞网页的加载。

`link`标签的类型有`preload` 、`prefetch`这两种，可以看到`preload` 是加载的是app.js文件，说明`preload` 是加载我们当前页面一定会用到的js资源，而`prefetch`加载的是我们的异步懒加载的组件，说明这两个js资源在我们当前页面可能会用到才会用`prefetch`来预加载这两个资源，其实`prefetch`加载的资源只会在当前浏览器空闲时才会加载这些资源，也就是说浏览器不一定会加载这些js资源，因为在当前的页面中一定不会用到这些资源所以不用担心页面渲染错误。

演示一下：

![image-20211224063707583](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211224063707583.png)

上图是home页面组件，可以看到没有加载about的js资源。

当我们点击about组件后。

![image-20211224063814896](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211224063814896.png)

他立马插入了一条`script`标签来加载about组件。这时候才会真正加载about组件资源。

这种的加载会提高页面首屏加载速度。

###  26.管理页面Head内容

客户端和服务端的页面模板除了body部分，其他部分都是一样的，现在我们的需求是把head部分也变成动态的。

我们需要安装一个第三方的插件-vue-meta：

```
npm i vue-meta
```

官方文档：https://vue-meta.nuxtjs.org/guide/#download-cdn

现在我们来把`vue-meta`配置到项目中来。

- 首先需要在通用入口，来配置：

`app.js`

```js
import Vue from 'vue'
import App from './app.vue'
import { createRouter } from './router'
import VueMeta from 'vue-meta' //引入vue-meta
Vue.use(VueMeta) //注册插件

Vue.mixin({ //使用mixin来给所有的vue实例配置一个公共的配置
  metaInfo:{
      //这个配置其实就是一个title模板 %s是一个占位符 如果当前组件提供metaInfo:{title:"xxxx"}的话title里的字符串就会替换到titleTemplate里的占位符当中 然后还需要在模板中使用 他就会把title里的字符串应用到当前页面的meta的title里
    titleTemplate:"%s - 红紫黑"
  }
})
export function createApp () {
  let router = createRouter()
  const app = new Vue({
    router, 
    render: h => h(App)
  })
  return { app,router }
}
```

- 在服务端入口配置

`entry-server.js`

```js
import {
  createApp
} from './app'

export default async context => {

  const {
    app,
    router
  } = createApp()
  const meta = app.$meta() // 这里是拿到页面配置的meta里的信息
  router.push(context.url)
  context.meta = meta // 然后把拿到的meta信息放到上下文对象里的meta属性里 这样做的目的是让页面html模板可以访问到meta里的数据
  await new Promise(router.onReady.bind(router))
  return app;
}
```

- 在页面模板中注入meta信息

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!--如下就是meta信息的占位符 这里就可以动态获取上下文传来的meta信息-->
  {{{ meta.inject().title.text() }}} 
  {{{ meta.inject().meta.text() }}}
</head>
<body>
  <!--vue-ssr-outlet-->
</body>
</html>
```

- 最后在要配置的组件里配置需要的标题信息了

`Home.vue`

```vue
<template>
  <div>
    <h1>home页面</h1>
  </div>
</template>

<script>
export default {
  metaInfo: { title: "首页" }, //这里就是需要配置标题信息的地方了  他最终会和之前在app.js里配置的titleTemplate混合 然后传到页面模板当中 因为titleTemplate是titleTemplate:"%s - 红紫黑"这样 最终就像这样： 首页 - 红紫黑 
  name: "home",
};
</script>
```

看一下项目展示：

![image-20211224081847248](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211224081847248.png)

### 27.数据预取和状态管理-思路分析

我们现在想在服务端就获取到数据拿到接口请求过来的数据，进行数据预取，但是如果直接在vue的组件的钩子函数里获取无法进行异步操作获取数据。

我们来准备一个`posts`组件

`posts.vue`

```vue
<template>
  <div>
    <h1>Post List</h1>
    <ul>
      <li v-for="post in posts" :key="post.id">{{ post.title }}</li>
    </ul>
  </div>
</template>

<script>
import axios from 'axios'
// import { mapState, mapActions } from 'vuex'

export default {
  name: 'PostList',
  metaInfo: {
    title: 'Posts'
  },
  data () {
    return {
      posts: []
    }
  },
   // 服务端渲染
  //     只支持 beforeCreate 和 created
  //     不会等待 beforeCreate 和 created 中的异步操作
  //     不支持响应式数据
  // 所有这种做法在服务端渲染中是不会工作的！！！
  async created () {
    console.log('Posts Created Start')
    const { data } = await axios({
      method: 'GET',
      url: 'https://cnodejs.org/api/v1/topics'
    })
    this.posts = data.data
    console.log('Posts Created End')
  }
}
</script>
```

打开浏览器看一下：

![image-20211224095141356](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211224095141356.png)

数据已经渲染出来了，但是这不是在服务端渲染的。

![image-20211224095227821](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211224095227821.png)

可以看到从服务端渲染发送过来的数据是没有进行渲染的。这个接口数据是从客户端获取渲染的。

官方文档：另一个需要关注的问题是在客户端，在挂载 (mount) 到客户端应用程序之前，需要获取到与服务器端应用程序完全相同的数据 - 否则，客户端应用程序会因为使用与服务器端应用程序不同的状态，然后导致混合失败。

这里从官方文档说明可以看到，客户端获取的数据要和服务端数据要一致才行，否则渲染混合失败，所以我们在在客户端发送的请求渲染在页面上是不行的。

是不是因为created在服务端没有执行呢？其实不是，是因为created不支持在服务端的异步任务。

那我们应该怎么做：

官方文档：

https://ssr.vuejs.org/zh/guide/data.html#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%8F%96%E5%AD%98%E5%82%A8%E5%AE%B9%E5%99%A8-data-store

在服务器端渲染(SSR)期间，我们本质上是在渲染我们应用程序的"快照"，所以如果应用程序依赖于一些异步数据，**那么在开始渲染过程之前，需要先预取和解析好这些数据**。

为了解决这个问题，获取的数据需要位于视图组件之外，即放置在专门的数据预取存储容器(data store)或"状态容器(state container)"中。首先，在服务器端，我们可以在渲染之前预取数据，并将数据填充到 store 中。此外，我们将在 HTML 中序列化(serialize)和内联预置(inline)状态。这样，在挂载(mount)到客户端应用程序之前，可以直接从 store 获取到内联预置(inline)状态。

由官方文档说明，我们可以看出，服务端异步数据预取需要在vuex里.

### 28.数据预取和状态管理-数据预取

接着我们来在项目中使用vuex:

- 首先我们先创建一个store文件夹

`index.js`

```js
import Vue from 'vue'
import Vuex from 'vuex'
import axios from 'axios'

Vue.use(Vuex)

export const createStore = () => {
  return new Vuex.Store({
    state: () => ({
      posts: []
    }),

    mutations: {
      setPosts (state, data) {
        state.posts = data
      }
    },

    actions: {
      // 在服务端渲染期间务必让 action 返回一个 Promise
      async getPosts ({ commit }) {
        // return new Promise()
        const { data } = await axios.get('https://cnodejs.org/api/v1/topics')
        commit('setPosts', data.data)
      }
    }
  })
}
```

- 然后在`app.js`里注册store

```js
import Vue from 'vue'
import App from './app.vue'
import { createRouter } from './router'
import VueMeta from 'vue-meta'
import {createStore} from "../src/store" //引入store
Vue.use(VueMeta)

Vue.mixin({
  metaInfo:{
    titleTemplate:"%s - 红紫黑"
  }
})
export function createApp () {
  let router = createRouter();
  let store = createStore();
  const app = new Vue({
    router, 
    store,//注册store
    // router,//把路由挂载到vue根实例中
    render: h => h(App)
  })
  return { app,router,store } //向外暴露出store
}
```

- 最后在组件里使用vuex，使用store里的数据

`posts.vue`

```vue
<template>
  <div>
    <h1>Post List</h1>
    <ul>
      <li v-for="post in posts" :key="post.id">{{ post.title }}</li>
    </ul>
  </div>
</template>

<script>
import { mapState, mapActions } from 'vuex'
export default {
  name: 'PostList',
  metaInfo: {
    title: 'Posts'
  },
  data () {
    return {
      // posts: []
    }
  },
  computed:{
   ...mapState(["posts"])
  },
  // Vue SSR 特殊为服务端渲染提供的一个生命周期钩子函数
  serverPrefetch () {
    // 发起 action，返回 Promise
    // this.$store.dispatch('getPosts')
    return this.getPosts()
  },
  methods: {
    ...mapActions(['getPosts'])
  }
}
</script>
```

这里使用了一个`serverPrefetch`函数，这个函数只有在服务端渲染之前的时候才会执行，特殊为服务端渲染提供的一个生命周期钩子函数。

然后打开浏览器：

![image-20211224112619091](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211224112619091.png)

我们已经在服务端拿到store里的数据了，但是在客户端没有被渲染出来？

因为客户端和服务端的数据没有同步，所以没有被渲染出来，导致合并失败。我们需要在客户端同时拿到数据渲染在客户端。

所以我们在下一步要解决这个客户端没有渲染的问题。

### 30.数据预取和状态管理-将预取数据同步到客户端

这里的客户端和服务端的数据没有同步，导致数据没有合并，渲染失败。在客户端没有看到服务端拿到的数据。

解决方案：

- 在服务端入口：

`entry-server.js`

```js
// entry-server.js
import { createApp } from './app'
export default async context => {
  const { app, router, store } = createApp() //解析出来store数据
  const meta = app.$meta()
  router.push(context.url)
  context.meta = meta
  await new Promise(router.onReady.bind(router))

  context.rendered = () => {
    // Renderer 会把 context.state 数据对象内联到页面模板中
    // 最终发送给客户端的页面中会包含一段脚本：window.__INITIAL_STATE__ = context.state
    // 客户端就要把页面中的 window.__INITIAL_STATE__ 拿出来填充到客户端 store 容器中
    context.state = store.state
  }
  return app
}
```

`context.rendered`函数会在服务端渲染完毕之后被调用，在这个函数里把store里的数据赋值给`context.state`，然后他会传入到页面模板中。

最终发送给客户端的页面中会包含一段脚本：`window.__INITIAL_STATE__ = context.state`，这样我们在页面模板里就有服务端的store里的数据。

- 最后在客户端入口

`entry-client.js`

```js
import { createApp } from './app'
const { app, router, store } = createApp()
//如果有在服务端传入来的store里的数据 window.__INITIAL_STATE__就是服务端传来的store里数据
if (window.__INITIAL_STATE__) {
    //然后把store里的数据替换到客户端的store
  store.replaceState(window.__INITIAL_STATE__)
}

router.onReady(() => {
  app.$mount('#app')
})

```

客户端就要把页面中的 `window.__INITIAL_STATE__ `拿出来填充到客户端 store 容器中，这样我们在客户端就会有服务端store里的数据了，这样客户端和服务端的store里数据就同步了。

![image-20211224115113837](C:\Users\洪志虎\AppData\Roaming\Typora\typora-user-images\image-20211224115113837.png)

可以看到浏览器客户端的的`window.__INITIAL_STATE__ `就有这个数据了，他会把数据填充到页面模板中来。

也可以看到客户端也可以正确渲染服务端请求来的数据了，并且同步到了客户端了。

